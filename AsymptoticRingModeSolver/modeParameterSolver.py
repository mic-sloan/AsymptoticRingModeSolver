# %%
from collections import OrderedDict
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import pickle
from ast import literal_eval
import shapely
import shapely.affinity
from scipy.constants import epsilon_0, speed_of_light
from shapely.ops import clip_by_rect
from skfem import Basis, ElementTriP0
from skfem.io.meshio import from_meshio
from tqdm import tqdm

from femwell.maxwell.waveguide import compute_modes, Modes
from femwell.mesh import mesh_from_OrderedDict
from femwell.visualization import plot_domains

def GetMaterialN(sellmeierCoeffs, wl):
    """ Returns the material refractive index for the given Sellmeier coefficients and wavelength """
    order = min([len(sellmeierCoeffs["A"]), len(sellmeierCoeffs["B"])])
    
    n_mat = 1
    for index in range(order):
        n_mat += sellmeierCoeffs["A"][index] * (wl**2) / (wl**2 - sellmeierCoeffs["B"][index]**2)
        
    return np.sqrt(n_mat)

def SolveBentOverlaps(simPars):
    """ Computes and returns the TE00 and TE01 mode properties for the given waveguide parameters """
    # Fixed Parameters
    numModesGen = 3                         # Number of spatial modes generated by the mode solver
    numModes = 2                            # Number of spatial modes saved
    
    # Required Parameters
    wavelength = simPars["wavelength"]                                      # Wavelength of the field (um)
    wg_width = simPars["wg_width"]                                          # Width of the waveguide (um)
    wg_thickness = simPars["wg_thickness"]                                  # Thickness (height) of the waveguide (um)
    bendCurvature = np.array(simPars["bendCurvature"], dtype=float)         # Array of bend curvature values (um^-1)
    sellmeierCoeffs_core = simPars["sellmeierCoeffs_core"]                  # Dictionary of Sellmeier coefficients for the core material
    sellmeierCoeffs_clad = simPars["sellmeierCoeffs_clad"]                  # Dictionary of Sellmeier 
    
    # Optional Paramaters
    pml_distance = wg_width / 2 + 2 if ("pml_distance" not in simPars) else simPars["pml_distance"]         # Distance to the pml region (um)
    pml_thickness = 2 if ("pml_thickness" not in simPars) else simPars["pml_thickness"]                     # Thickness of the pml region (um)
    resolutions = dict(core={"resolution": 0.06, "distance": 0.5}, clad={"resolution": 0.3, "distance" : 0.5}) if ("resolutions" not in simPars) else simPars["resolutions"]
    
    # Define the core and the environment geometry
    core = shapely.geometry.box(-wg_width / 2, 0, +wg_width / 2, wg_thickness)
    env = shapely.geometry.box(-1 - wg_width / 2, -1, pml_distance + pml_thickness, wg_thickness + 1)
    
    # Create the core and cladding polygons
    polygons = OrderedDict(core=core,clad=env,)
    
    # Generate the mesh
    mesh = from_meshio(mesh_from_OrderedDict(polygons, resolutions, default_resolution_max=10))
    
    # Construct the basis
    basis0 = Basis(mesh, ElementTriP0())
    epsilon = basis0.zeros(dtype=complex)
    n_core = GetMaterialN(sellmeierCoeffs_core, wavelength)
    n_clad = GetMaterialN(sellmeierCoeffs_clad, wavelength)    
    for subdomain, n in {"core": n_core, "clad": n_clad}.items():
        epsilon[basis0.get_dofs(elements=subdomain)] = n**2
    epsilon += basis0.project(lambda x: -10j * np.maximum(0, x[0] - pml_distance) ** 2, dtype=complex)
    
    # Compute the modes for a straight waveguide
    modes_straight = compute_modes(basis0, epsilon, wavelength=wavelength, num_modes=numModesGen, order=2, radius=np.inf)
    
    # Solve for the bent modes
    lam_guess = modes_straight[0].n_eff
    bentModes = []
    for curve in bendCurvature:
        radius = np.inf if (curve == 0) else 1/curve
        bentModes.append(compute_modes(basis0, epsilon, wavelength=wavelength, num_modes=numModesGen, order=2, radius=radius, n_guess=lam_guess, solver="scipy"))
        lam_guess = bentModes[-1][0].n_eff
        
    # Find the first two TE modes and remove the rest
    Ncurve = len(bendCurvature)
    for curveIndex in range(Ncurve):
        parsedModes = []
        
        for modeIndex in range(numModesGen):
            if (bentModes[curveIndex][modeIndex].te_fraction > 0.5):
                parsedModes.append(bentModes[curveIndex][modeIndex])
                if (len(parsedModes) >= numModes): break
        
        if (len(parsedModes) == numModes): bentModes[curveIndex] = Modes(parsedModes)
        
    # Extract the values of interest
    modeOverlaps = np.zeros((numModes, numModes, Ncurve, Ncurve), dtype=complex)
    includeOverlap = np.zeros((numModes, numModes, Ncurve, Ncurve), dtype=int)
    n_eff = np.zeros((numModes, Ncurve), dtype=float)
    loss = np.zeros((numModes, Ncurve), dtype=float)
    te_frac = np.zeros((numModes, Ncurve), dtype=float)
    for inCurve in range(Ncurve):
        for inMode in range(numModes):
            n_eff[inMode, inCurve] = np.real(bentModes[inCurve][inMode].n_eff)
            loss[inMode, inCurve] = np.real(bentModes[inCurve][inMode].calculate_propagation_loss(0.01))
            te_frac[inMode, inCurve] = np.real(bentModes[inCurve][inMode].te_fraction)
        
            for outCurve in range(Ncurve):
                for outMode in range(numModes):
                    if (bentModes[inCurve][inMode].te_fraction > 0.5 and bentModes[outCurve][outMode].te_fraction > 0.5): includeOverlap[inMode, outMode, inCurve, outCurve] = 1
                    modeOverlaps[inMode, outMode, inCurve, outCurve] = (bentModes[inCurve][inMode]).calculate_overlap(bentModes[outCurve][outMode])
      
    # Add a global phase to the mode definitions for the overlap calculation such that the overlap matrix varies gradually in phase 
    modePhases = np.zeros((numModes, Ncurve), dtype=complex)
    for modeIndex in range(numModes):
        modePhases[modeIndex, :] = np.exp(1j * np.angle(modeOverlaps[modeIndex, modeIndex, :, 0]))
        
    for inMode in range(numModes):
        for outMode in range(numModes):
            modeOverlaps[inMode, outMode, :, :] = np.diag(np.conj(modePhases[inMode, :])) @ modeOverlaps[inMode, outMode, :, :] @ np.diag(modePhases[outMode, :])   
    
    # Compute the overlap strength
    overlapStrength = np.zeros((numModes, numModes, Ncurve), dtype=complex)
    for inMode in range(numModes):
        for outMode in range(numModes):
            overlapStrength[inMode, outMode, :], sigma2 = ComputeOverlapStrength_selfCoupling(bendCurvature, modeOverlaps[inMode, outMode, :, :], includeOverlap[inMode, outMode, :, :], plotFit=False) if (inMode == outMode) else ComputeOverlapStrength_crossCoupling(bendCurvature, modeOverlaps[inMode, outMode, :, :], includeOverlap[inMode, outMode, :, :], plotFit=False)
     
    # Add an additional phase to the cross-coupling terms
    overlapStrength[0, 1, :] = overlapStrength[0, 1, :] * np.exp(-1j * np.angle(overlapStrength[0, 1, 0]))
    overlapStrength[1, 0, :] = overlapStrength[1, 0, :] * np.exp(-1j * np.angle(overlapStrength[1, 0, 0]))
    
    # Construct the data frame and return it    
    data = {
        "wavelength" : wavelength * np.ones(numModes * Ncurve, dtype=float), 
        "wg_width" : wg_width * np.ones(numModes * Ncurve, dtype=float), 
        "wg_thickness" : wg_thickness * np.ones(numModes * Ncurve, dtype=float), 
        "bend_curvature" : np.tile(bendCurvature, numModes),  
        "mode_number" : np.repeat(np.arange(1, numModes+1), Ncurve),
        "n_eff" : np.concatenate(n_eff),  
        "loss" : np.concatenate(loss),
        "te_fraction" : np.concatenate(te_frac), 
        "selfOverlapStrength" : np.concatenate([overlapStrength[0, 0, :], overlapStrength[1, 1, :]]),
        #"crossOverlapStrength" : np.concatenate([overlapStrength[0, 1, :] * np.exp(-1j * np.angle(overlapStrength[0, 1, 0])), overlapStrength[1, 0, :] * np.exp(-1j * np.angle(overlapStrength[1, 0, 0]))]) 
        "crossOverlapStrength" : np.concatenate([overlapStrength[0, 1, :], overlapStrength[1, 0, :]]) 
        }
    df = pd.DataFrame(data)
    
    return df

def MakeDataSet(simPars):
    """ Make a data set of mode properties by partitionaing the input into smaller set and merging the results """
    N_bend = simPars["bendCurvature"].size
    widthVec = simPars["wg_width"]
    thicknessVec = simPars["wg_thickness"]
    wavelengthVec = simPars["wavelength"]
    
    df = 0
    newDF = True
    numIteration = 2 * widthVec.size * thicknessVec.size * wavelengthVec.size * N_bend
    progress_bar = tqdm(total=numIteration, desc="Modes")
    for width in widthVec:
        for thickness in thicknessVec:
            for wavelength in wavelengthVec:
                tempSimPars = simPars
                tempSimPars["wg_width"] = width
                tempSimPars["wg_thickness"] = thickness
                tempSimPars["wavelength"] = wavelength
                
                tempDF = SolveBentOverlaps(tempSimPars)
                progress_bar.update(2 * N_bend)
                
                if newDF:
                    df = tempDF
                    newDF = False
                else:
                    df = pd.concat([df, tempDF], ignore_index=True, sort=False)
                    
    return df

def ComputeOverlapStrength_selfCoupling(bendCurvature, overlapMat, includeOverlap, maxOrder=4, plotFit=False):
    """ Performs a 2D fit on the provided matrix of self-overlap values """
    N = len(bendCurvature)**2
    
    # Find the indicies of all the entries to be ignored in the fit
    overlapInclude = includeOverlap.reshape(N)
    popVals = np.where(overlapInclude == 0)
    
    # Perform a least squares fit to a 2D polynomial, of order given by max order, in terms of the input curvature and the curvature difference
    # We use the property that at zero phase difference the overlap must equal 1, and that a complex conjugation of the overlap corresponds to
    # a negative of the curvature difference to reduce the dimesionality of the fitting function parameters.
    inCurve, outCurve = np.meshgrid(bendCurvature, bendCurvature, indexing="ij")
    inCurve_data = np.delete(inCurve.reshape(N), popVals)
    outCurve_data = np.delete(outCurve.reshape(N), popVals)
    curveDiff_data = inCurve_data - outCurve_data
    fitting_data = np.delete(overlapMat.reshape(N) - 1, popVals)
    
    pIndices = []; qIndices = []
    for p in range(1, maxOrder + 1):
        for q in range(0, maxOrder - p + 1):
            pIndices.append(p); qIndices.append(q)
    
    parDim = len(pIndices)
    alphaVec = np.zeros(parDim, dtype=float)
    gammaMat = np.zeros((parDim, parDim), dtype=float)
    for diff, curve, overlap in zip(curveDiff_data, inCurve_data, fitting_data):
        for parIndex, p, q in zip(range(parDim), pIndices, qIndices):
            fittingVal = np.real(overlap) if (p % 2 == 0) else np.imag(overlap)
            alphaVec[parIndex] += fittingVal * (diff**p) * (curve**q)
            
            for parIndex_p, p_p, q_p in zip(range(parDim), pIndices, qIndices):
                if ((p + p_p) % 2 == 0):
                    gammaMat[parIndex, parIndex_p] += (diff**(p + p_p)) * (curve**(q + q_p))
                    
    fittedPars = np.linalg.inv(gammaMat) @ alphaVec
    
    # Compute the squared residual
    S = (np.transpose(fitting_data) @ fitting_data) - 2 * (np.transpose(fittedPars) @ alphaVec) + np.transpose(fittedPars) @ gammaMat @ fittedPars
    sigma2 = abs(S / (len(fitting_data) - len(fittedPars)))
     
    # Optionally plot the fitted function over the computed overlap matrix
    if (plotFit == True):
        Ncurve = 100
        curveAxis = np.linspace(bendCurvature[0], bendCurvature[-1], Ncurve)
        X, Y = np.meshgrid(curveAxis, curveAxis, indexing="ij")
            
        FittedOverlap = np.ones((Ncurve, Ncurve), dtype=np.complex128)
        for parIndex, p, q in zip(range(parDim), pIndices, qIndices):
            tempVal = fittedPars[parIndex] * ((X - Y)**p) * (X**q)
            if (p % 2 != 0): tempVal = 1j * tempVal
            
            FittedOverlap += tempVal
         
        fig = plt.figure(figsize=plt.figaspect(0.5))
        
        ax = fig.add_subplot(1, 2, 1, projection='3d')
        ax.plot_surface(X, Y, np.real(FittedOverlap))
        ax.scatter(inCurve_data, outCurve_data, np.real(fitting_data) + 1)
        ax.set_xlabel("Input curvature (um^-1)")
        ax.set_ylabel("Output curvature (um^-1)")
        ax.set_title("Real")
        
        ax = fig.add_subplot(1, 2, 2, projection='3d')
        ax.plot_surface(X, Y, np.imag(FittedOverlap))
        ax.scatter(inCurve_data, outCurve_data, np.imag(fitting_data))
        ax.set_xlabel("Input curvature (um^-1)")
        ax.set_ylabel("Output curvature (um^-1)")
        ax.set_title("Imaginary")
        
        plt.show()
        
    # Extract the overlap strength
    overlapStrength = np.zeros(len(bendCurvature), dtype=complex)
    for q in range(maxOrder): overlapStrength += 1j * fittedPars[q] * (bendCurvature**q)
    
    return [overlapStrength, sigma2]

def ComputeOverlapStrength_crossCoupling(bendCurvature, overlapMat, includeOverlap, maxOrder=4, plotFit=False):
    """ Performs a 2D fit on the provided matrix of cross-overlap values """
    N = len(bendCurvature)**2
    
    # Find the indicies of all the entries to be ignored in the fit
    overlapInclude = includeOverlap.reshape(N)
    popVals = np.where(overlapInclude == 0)
    
    # Perform a least squares fit to a 2D polynomial, of order given by max order, in terms of the input curvature and the curvature difference
    # We use the property that at zero phase difference the overlap must equal 0 to reduce the dimesionality of the fitting function parameters.
    inCurve, outCurve = np.meshgrid(bendCurvature, bendCurvature, indexing="ij")
    inCurve_data = np.delete(inCurve.reshape(N), popVals)
    outCurve_data = np.delete(outCurve.reshape(N), popVals)
    curveDiff_data = inCurve_data - outCurve_data
    fitting_data = np.delete(overlapMat.reshape(N), popVals)
    overlapInclude = includeOverlap.reshape(N)
    
    pIndices = []; qIndices = []
    for p in range(1, maxOrder + 1):
        for q in range(0, maxOrder - p + 1):
            pIndices.append(p); qIndices.append(q)
    
    parDim = len(pIndices)
    alphaVec = np.zeros(parDim, dtype=complex)
    gammaMat = np.zeros((parDim, parDim), dtype=float)
    for diff, curve, overlap in zip(curveDiff_data, inCurve_data, fitting_data):
        for parIndex, p, q in zip(range(parDim), pIndices, qIndices):
            alphaVec[parIndex] += overlap * (diff**p) * (curve**q)
            
            for parIndex_p, p_p, q_p in zip(range(parDim), pIndices, qIndices):
                gammaMat[parIndex, parIndex_p] += (diff**(p + p_p)) * (curve**(q + q_p))
                    
    fittedPars = np.linalg.inv(gammaMat) @ alphaVec
    
    # Compute the squared residual
    S = (np.transpose(fitting_data) @ fitting_data) - 2 * (np.transpose(fittedPars) @ alphaVec) + np.transpose(fittedPars) @ gammaMat @ fittedPars
    sigma2 = abs(S / (len(fitting_data) - len(fittedPars)))
        
    # Optionally plot the fitted function over the computed overlap matrix
    if (plotFit == True):
        Ncurve = 100
        curveAxis = np.linspace(bendCurvature[0], bendCurvature[-1], Ncurve)
        X, Y = np.meshgrid(curveAxis, curveAxis, indexing="ij")
            
        FittedOverlap = np.zeros((Ncurve, Ncurve), dtype=np.complex128)
        for parIndex, p, q in zip(range(parDim), pIndices, qIndices):
            tempVal = fittedPars[parIndex] * ((X - Y)**p) * (X**q)
            
            FittedOverlap += tempVal
         
        fig = plt.figure(figsize=plt.figaspect(0.5))
        
        ax = fig.add_subplot(1, 2, 1, projection='3d')
        ax.plot_surface(X, Y, np.real(FittedOverlap))
        ax.scatter(inCurve_data, outCurve_data, np.real(fitting_data))
        ax.set_xlabel("Input curvature (um^-1)")
        ax.set_ylabel("Output curvature (um^-1)")
        ax.set_title("Real")
        
        ax = fig.add_subplot(1, 2, 2, projection='3d')
        ax.plot_surface(X, Y, np.imag(FittedOverlap))
        ax.scatter(inCurve_data, outCurve_data, np.imag(fitting_data))
        ax.set_xlabel("Input curvature (um^-1)")
        ax.set_ylabel("Output curvature (um^-1)")
        ax.set_title("Imaginary")
        
        plt.show()
        
    # Extract the overlap strength
    overlapStrength = np.zeros(len(bendCurvature), dtype=complex)
    for q in range(maxOrder): overlapStrength += fittedPars[q] * (bendCurvature**q)
    
    return [overlapStrength, sigma2]

def Fit3Dpoly(xData, yData, zData, fData, maxOrder=4, lowBiasFactor=[0, 0, 0]):
    """ Performs a 3D polynomial fit on the function with values (fData) at the points specified by (xData, yData, zData) """
    minArgs = [min(xData), min(yData), min(zData)]
    maxArgs = [max(xData), max(yData), max(zData)]
    
    pIndices = []; qIndices = []; kIndices = []
    for p in range(maxOrder + 1):
        for q in range(maxOrder + 1 - p):
            for k in range(maxOrder + 1 - p - q):
                pIndices.append(p); qIndices.append(q); kIndices.append(k)
                
    parDim = len(pIndices)
    betaVec = np.zeros(parDim, dtype=complex)
    gammaMat = np.zeros((parDim, parDim), dtype=complex)
    for x, y, z, f in zip(xData, yData, zData, fData):
        vals = [x, y, z]
        weight = 1 + sum([(lowBiasFactor[par] * (vals[par] - maxArgs[par]) / (minArgs[par] - maxArgs[par])) for par in range(3)])
        for p, q, k, parIndex in zip(pIndices, qIndices, kIndices, range(parDim)):
            betaVec[parIndex] += weight * f * (x**p) * (y**q) * (z**k)
            
            for p_p, q_p, k_p, parIndex_p in zip(pIndices, qIndices, kIndices, range(parDim)):
                gammaMat[parIndex, parIndex_p] += weight * (x**(p + p_p)) * (y**(q + q_p)) * (z**(k + k_p))
                
    fittedPars_vec = np.linalg.inv(gammaMat) @ betaVec
    fittedPars = np.zeros((maxOrder+1, maxOrder+1, maxOrder+1), dtype=complex)
    for p, q, k, parIndex in zip(pIndices, qIndices, kIndices, range(parDim)):
        fittedPars[p, q, k] = fittedPars_vec[parIndex]
        
    return fittedPars
    

def GetFitParameters(dataFiles):
    """ Performs the 3D fit for each of the relevant waveguide properties for a given vector of input data files """
    # First, we read in and merged the data from the given data files
    dfVec = []
    for fileName in dataFiles:
        dfVec.append(pd.read_csv(fileName))
        
    df_merged = pd.concat(dfVec, ignore_index=True, sort=False)
    df_modeSplit = [df_merged.loc[df_merged["mode_number"] == 1], df_merged.loc[df_merged["mode_number"] == 2]]
    
    wavelength_data = np.array([df_modeSplit[0]["wavelength"].tolist(), df_modeSplit[1]["wavelength"].tolist()], dtype=float)
    wg_width_data = np.array([df_modeSplit[0]["wg_width"].tolist(), df_modeSplit[1]["wg_width"].tolist()], dtype=float)
    bend_curvature_data = np.array([df_modeSplit[0]["bend_curvature"].tolist(), df_modeSplit[1]["bend_curvature"].tolist()], dtype=float)
    n_eff_data = np.array([df_modeSplit[0]["n_eff"].tolist(), df_modeSplit[1]["n_eff"].tolist()], dtype=float)
    loss_data = np.array([df_modeSplit[0]["loss"].tolist(), df_modeSplit[1]["loss"].tolist()], dtype=float)
    self_os_data = np.array([df_modeSplit[0]["selfOverlapStrength"].tolist(), df_modeSplit[1]["selfOverlapStrength"].tolist()], dtype=complex)
    cross_os_data = np.array([df_modeSplit[0]["crossOverlapStrength"].tolist(), df_modeSplit[1]["crossOverlapStrength"].tolist()], dtype=complex)
    
    # Perform the fitting on each of the properties
    n_eff_fit_mode1 = Fit3Dpoly(wavelength_data[0], bend_curvature_data[0], wg_width_data[0], n_eff_data[0], maxOrder=3)
    n_eff_fit_mode2 = Fit3Dpoly(wavelength_data[1], bend_curvature_data[1], wg_width_data[1], n_eff_data[1], maxOrder=3)
    loss_fit_mode1 = Fit3Dpoly(wavelength_data[0], bend_curvature_data[0], wg_width_data[0], loss_data[0], maxOrder=4)
    loss_fit_mode2 = Fit3Dpoly(wavelength_data[1], bend_curvature_data[1], wg_width_data[1], loss_data[1], maxOrder=4)
    selfCoupling_fit_mode1 = Fit3Dpoly(wavelength_data[0], bend_curvature_data[0], wg_width_data[0], self_os_data[0], maxOrder=4)
    selfCoupling_fit_mode2 = Fit3Dpoly(wavelength_data[1], bend_curvature_data[1], wg_width_data[1], self_os_data[1], maxOrder=4)
    crossCoupling_fit_mode1 = Fit3Dpoly(wavelength_data[0], bend_curvature_data[0], wg_width_data[0], cross_os_data[0], maxOrder=4, lowBiasFactor=[0, 1, 0])
    crossCoupling_fit_mode2 = Fit3Dpoly(wavelength_data[1], bend_curvature_data[1], wg_width_data[1], cross_os_data[1], maxOrder=4, lowBiasFactor=[0, 1, 0])
    
    # Save the results to a dictionary and  return it
    fittedPars = {
        "neffPars_mode1_raw" : n_eff_fit_mode1,
        "neffPars_mode2_raw" : n_eff_fit_mode2,
        "radLossPars_mode1_raw" : loss_fit_mode1,
        "radLossPars_mode2_raw" : loss_fit_mode2,
        "selfHOMcoupling_mode1_raw" : selfCoupling_fit_mode1,
        "selfHOMcoupling_mode2_raw" : selfCoupling_fit_mode2,
        "crossHOMcoupling_mode1_raw" : crossCoupling_fit_mode1,
        "crossHOMcoupling_mode2_raw" : crossCoupling_fit_mode2,
    }
    
    return fittedPars

def GetFittedFunctionValue(fittingCoeffs, x, y, z):
    """ Computes the value of the fittes function given the fitting parameters in (fittinCoeffs) and the points in (x, y, z) """
    val = 0
    for xIndex in range(len(fittingCoeffs[:, 0, 0])):
        for yIndex in range(len(fittingCoeffs[0, :, 0])):
            for zIndex in range(len(fittingCoeffs[0, 0, :])):
                val += fittingCoeffs[xIndex, yIndex, zIndex] * (x**xIndex) * (y**yIndex) * (z**zIndex)
                
    return val

# %%
